<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hushenghui&#39;s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="Insights on Technology, Life, and Reflections">
<meta property="og:type" content="website">
<meta property="og:title" content="Hushenghui&#39;s Blog">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Hushenghui&#39;s Blog">
<meta property="og:description" content="Insights on Technology, Life, and Reflections">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Hushenghui">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hushenghui's Blog" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 7.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hushenghui&#39;s Blog</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-面经（2024.11.18-2024.11.24）" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/11/26/%E9%9D%A2%E7%BB%8F%EF%BC%882024.11.18-2024.11.24%EF%BC%89/" class="article-date">
  <time class="dt-published" datetime="2024-11-26T07:15:51.000Z" itemprop="datePublished">2024-11-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/11/26/%E9%9D%A2%E7%BB%8F%EF%BC%882024.11.18-2024.11.24%EF%BC%89/">面经（2024.11.18-2024.11.24）</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="SpringAOP-如何实现？"><a href="#SpringAOP-如何实现？" class="headerlink" title="SpringAOP 如何实现？"></a>SpringAOP 如何实现？</h3><p>依赖于动态代理技术，动态代理是在运行时动态生成代理对象，而不是在编译时。</p>
<p>SpringAOP 支持两种动态代理</p>
<ul>
<li><p>基于 JDK 的动态代理：使用 Proxy 类和 InvocationHandler 接口实现</p>
<ul>
<li>这种方式需要代理的类实现一个或多个接口</li>
</ul>
</li>
<li><p>基于 CGLIB 的动态代理：当被代理的类没有实现接口时，Spring 会使用 CGLIB 库生成一个被代理的子类作为代理</p>
<ul>
<li>Code Generation Library 是一个第三方代码生成库，通过继承方式实现代理</li>
</ul>
</li>
</ul>
<h3 id="AOP-实现常用注解？"><a href="#AOP-实现常用注解？" class="headerlink" title="AOP 实现常用注解？"></a>AOP 实现常用注解？</h3><ul>
<li>@Aspect：用于定义切面，标注在切面类上。</li>
<li>@Pointcut：定义切点，标注在方法上，用于指定连接点。</li>
<li>@Before：在方法执行之前执行通知。</li>
<li>@After：在方法执行之后执行通知。</li>
<li>@Around：在方法执行前后都执行通知。</li>
<li>@AfterReturning：在方法执行后返回结果后执行通知。</li>
<li>@AfterThrowing：在方法抛出异常后执行通知。</li>
<li>@Advice：通用的通知类型，可以替代@Before、@After等。</li>
</ul>
<h3 id="两者区别？"><a href="#两者区别？" class="headerlink" title="两者区别？"></a>两者区别？</h3><ul>
<li><p>实现方式</p>
<ul>
<li>JDK 动态代理基于接口实现，要求被代理的类必须实现一个或多个接口，代理对象会实现这些接口并将方法调用委托给目标对象</li>
<li>CGLIB 动态代理基于类实现，通过生成目标类的子类来实现代理，不要求目标类必须实现接口</li>
</ul>
</li>
<li><p>性能差异</p>
<ul>
<li>JDK 动态代理创建代理对象开销较小，但每次方法都涉及反射，因此频繁调用的场景下性能略低</li>
<li>CGLIB 动态代理生成代理类开销较大，但通过字节码操作减少反射开销，因此实际方法调用性能更高</li>
</ul>
</li>
</ul>
<p><strong>JDK动态代理</strong>：如果目标对象实现了接口，Spring默认使用JDK动态代理（首选）</p>
<p><strong>CGLib代理</strong>：如果目标对象没有实现任何接口，Spring AOP 会自动使用 CGLib 动态代理</p>
<ul>
<li>在 Spring 配置中，也可以强制使用CGLib代理（通过设置<code>proxyTargetClass=true</code>​）</li>
</ul>
<p>‍</p>
<h3 id="MySQL-事务"><a href="#MySQL-事务" class="headerlink" title="MySQL 事务"></a>MySQL 事务</h3><p>事务是什么？</p>
<ul>
<li>事务是逻辑上的一组操作，要么全部执行，要么全部不执行；</li>
<li>事务分为数据库事务和分布式事务；</li>
</ul>
<p>数据库事务是什么？</p>
<ul>
<li>数据库事务是系统执行过程中的一个逻辑单位，由一个有限的数据库操作序列构成。这些操作通常包括增、删、改、查等。</li>
</ul>
<p>特性：数据库事务满足 ACID 四大特性，分别是：</p>
<ul>
<li>原子性：事务是最小的、不可分割的执行单位，事务中的操作要么全部执行，要么全部不执行；</li>
<li>一致性：事务执行前后，数据保持一致，例如转账业务，无论事务是否成功，转账者和收款者的总额应是不变的；</li>
<li>隔离性：并发的各个事务之间不会相互干扰，一个事务的中间状态对其它事务不可见；</li>
<li>持久性：事务一旦提交，它对数据库的提交是永久性的，即使系统发生故障数据也不会丢失。</li>
</ul>
<p>只有保证了数据的持久性、原子性和隔离性后，一致性才会得到保障，A&#x2F;I&#x2F;D 是手段，D 是目的；</p>
<p>应用场景：</p>
<ul>
<li>主要应用于单个数据库内多个数据表之间的数据一致性保障，如银行转账、库存管理等功能。</li>
</ul>
<p>并发事务带来的影响？</p>
<ul>
<li>更新丢失：多个事务同时选择同一行数据，都基于最初选定的值更新该行，由于每个事务都不清楚其它事务的存在，就会发生更新丢失的问题。最后提交的事务将覆盖之前其它事务所做的更新；</li>
<li>脏读：事务 A 读取了事务 B 未提交的数据，而该数据随后被事务 B 回滚，导致事务 A 读取到无效的数据（脏数据）；</li>
<li>不可重复读：同一事务中，多次读取同一行数据时，得到不同的结果。这是由于在事务执行期间，其它事务修改了该行数据导致；</li>
<li>幻读：同一事务中，多次查询时，得到数据集的行数不一致（好像出现了幻觉）。这是由于在事务执行期间，其它事务插入或删除了某些数据导致。</li>
</ul>
<p>解决方案：</p>
<p>为了解决这些并发事务带来的问题，MySQL提供了不同的事务隔离级别，这些事务隔离级别定义了事务之间如何相互隔离以及可以访问的数据，MySQL 的四种事务隔离级别如下：</p>
<ul>
<li>读未提交：允许事务 A 读取事务 B 未提交的数据，可能会导致脏读、不可重复读、幻读问题；</li>
<li>读已提交：只允许事务 A 读取事务 B 已提交的数据，可以避免脏读问题，但可能出现不可重复读、幻读问题；</li>
<li>可重复读（默认）：确保同一事务多次读取同一行数据得到的结果是一致的，可以避免脏读、不可重复问题，但可能出现幻读问题（在MySQL 的 innoDB 存储引擎中，通过 next-key-locking 机制可以避免幻读）；</li>
<li>可序列化（可串行化）：事务的最高隔离级别，通过将事务完全序列化执行来避免脏读、不可重复读、幻读问题，但会显著降低并发性能。</li>
</ul>
<p>实际应用场景应根据具体业务来决定合适的事务隔离级别，以平衡并发性能和数据一致性；同时，还可以使用锁机制（如行级锁、表级锁、范围锁等）来进一步控制并发事务的访问。</p>
<p>MySQL 的隔离级别实现原理？</p>
<ul>
<li>基于锁和 MVCC 机制共同实现，读未提交、读已提交、可重复读是基于 MVCC 技术实现，可串行化是通过加锁实现。</li>
</ul>
<p>MVCC 是什么？</p>
<ul>
<li>MVCC，多版本并发控制，是一种用于实现数据库并发访问控制的机制。它允许多个用户同时读写同一行数据，通过为每行数据维护多个版本来避免读写冲突，从而提高了数据库在高并发环境下的性能和响应数据。</li>
</ul>
<p>核心思想：</p>
<ul>
<li>在读写操作期间保存多个数据版本，以提供并发事务间的隔离性。这里的多版本是指某一条记录的多个版本同时存在，当事务需要读取数据时，它会读取对应版本的数据，而不是最新的数据，从而避免了使用传统锁机制来管理数据的并发访问；</li>
</ul>
<p>实现原理：</p>
<ul>
<li><p>Undo Log 是指在每个数据对象上维护的 Undo Log 记录链表，每张表都会有与之对应的 Undo Log 链，用于记录修改前的数据信息，以方便数据回滚。</p>
<ul>
<li>当执行 update 和 delete 操作时，会产生 Undo Log。这些 Undo Log 在数据回滚时需要用到，同时在快照读也需要用到，不能随便删除。</li>
</ul>
</li>
<li><p>Read View 是用于管理事务之间数据可见性的一种机制。它在特定时刻为事务创建一个快照，该快照包含了该时刻所有未提交事务的事务标识符，及其它辅助信息。</p>
<ul>
<li>读已提交隔离级别下，每次快照读都会生成一个新的 Read View；而在可重复读隔离级别下，同一个事务会复用同一个 Read View；</li>
</ul>
</li>
</ul>
<p>面试版本：</p>
<p>MVCC 多版本并发控制指的是维护同一个数据的多个版本，使读写没有冲突</p>
<p>总共有三部分来实现MVCC</p>
<ol>
<li><p>隐藏字段：事务 id 和回滚指针；事务 id 是事务的唯一标识符，会在每一次的操作后进行自增。回滚指针则指向上一版本的事务记录地址，方便后续回滚；</p>
</li>
<li><p>undo log 回滚日志，存储老版本数据；</p>
</li>
<li><p>readView 快照读</p>
<ul>
<li><p>解决事务选择版本问题，且不同隔离级别的快照读是不同的。</p>
<ul>
<li>RC 是每一次执行快照读都生成 readView；</li>
<li>RR 是第一次执行生成快照读，后续复用；</li>
</ul>
</li>
</ul>
</li>
</ol>
<p>undo log 和 redo log 区别：</p>
<ul>
<li><p>undo log：回滚日志，用与记录数据被修改前的信息，提供回滚数据和 MVCC 使用。</p>
<ul>
<li><p>Undo Log 是逻辑日志</p>
<ul>
<li>当 delete 一条记录时，undo log 会相反的记录一条 insert 记录；</li>
<li>当 update 一条纪录时，它记录一条对应相反的 update 记录；</li>
<li>当执行 rollback 时，可以从 undo log 中的逻辑记录读取到相应记录并进行回滚，实现事务的原子性和一致性；</li>
</ul>
</li>
</ul>
</li>
<li><p>redo log：重做日志，记录事务提交时对数据的物理修改，用来实现事务的持久性，供数据恢复使用；</p>
</li>
</ul>
<p>‍</p>
<p>‍</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/11/26/%E9%9D%A2%E7%BB%8F%EF%BC%882024.11.18-2024.11.24%EF%BC%89/" data-id="cm3y4jdub0002cseg5548af6f" data-title="面经（2024.11.18-2024.11.24）" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-面经" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/11/26/%E9%9D%A2%E7%BB%8F/" class="article-date">
  <time class="dt-published" datetime="2024-11-26T07:15:51.000Z" itemprop="datePublished">2024-11-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/11/26/%E9%9D%A2%E7%BB%8F/">面经</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/11/26/%E9%9D%A2%E7%BB%8F/" data-id="cm3y4jduc0004cseg5yoidv0e" data-title="面经" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-常见漏洞演示与修复建议" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/11/07/%E5%B8%B8%E8%A7%81%E6%BC%8F%E6%B4%9E%E6%BC%94%E7%A4%BA%E4%B8%8E%E4%BF%AE%E5%A4%8D%E5%BB%BA%E8%AE%AE/" class="article-date">
  <time class="dt-published" datetime="2024-11-07T08:49:03.000Z" itemprop="datePublished">2024-11-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/11/07/%E5%B8%B8%E8%A7%81%E6%BC%8F%E6%B4%9E%E6%BC%94%E7%A4%BA%E4%B8%8E%E4%BF%AE%E5%A4%8D%E5%BB%BA%E8%AE%AE/">常见漏洞演示与修复建议</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="SQL-注入漏洞"><a href="#SQL-注入漏洞" class="headerlink" title="SQL 注入漏洞"></a>SQL 注入漏洞</h3><p><strong>漏洞原理</strong></p>
<p>服务器端未对用户输入的数据进行充分的验证和处理，将用户提供的数据直接拼接到 SQL 语句中，攻击者通过构造恶意输入，将额外的 SQL 代码插入原始的查询语句中，从而篡改逻辑、执行非法操作。</p>
<p>攻击者通过注入恶意的SQL语句来执行非法操作，获取敏感信息。</p>
<p><strong>漏洞产生的场景</strong></p>
<ul>
<li>JDBC 直接拼接参数导致 SQL 漏洞</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;SELECT * FROM test_sql_inject WHERE name = &#x27;&quot;</span> + name + <span class="string">&quot;&#x27; and password = &#x27;&quot;</span> + password + <span class="string">&quot;&#x27;&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当password = &quot;test_1&#x27; or &#x27;1&#x27; = &#x27;1&#x27;&quot; 时，该SQL会变成：</span></span><br><span class="line">SELECT * FROM test_sql_inject <span class="type">WHERE</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&#x27;name&#x27;</span> <span class="type">and</span> <span class="variable">password</span> <span class="operator">=</span> <span class="string">&#x27;test_1&#x27;</span> or <span class="string">&#x27;1&#x27;</span> = <span class="string">&#x27;1&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>以上情况将会导致该查询可以绕过密码验证直接查询到 name &#x3D; ‘name’ 的全部信息；</p>
<ul>
<li>MyBatis 使用 ${} 导致的拼接漏洞</li>
</ul>
<p>使用<code>$&#123;&#125;</code>​会直接将变量值插入到SQL语句中，而不会进行任何转义或参数化处理。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectUserByUsername&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.example.User&quot;</span>&gt;</span>  </span><br><span class="line"> 	SELECT * FROM users WHERE username = &#x27;$&#123;username&#125;&#x27;  </span><br><span class="line"> <span class="tag">&lt;/<span class="name">select</span>&gt;</span>  </span><br></pre></td></tr></table></figure>

<p>​<code>userInput</code>​被设置为<code>&#39; OR &#39;1&#39;=&#39;1</code>​时，拼接后的SQL语句将变为：</p>
<p>SELECT * FROM users WHERE username &#x3D; ‘’ OR ‘1’&#x3D;’1’</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设这是用户输入，但实际上是攻击者控制的恶意输入  </span></span><br><span class="line"><span class="type">String</span> <span class="variable">userInput</span> <span class="operator">=</span> <span class="string">&quot;&#x27; OR &#x27;1&#x27;=&#x27;1&quot;</span>; <span class="comment">// 这是一个典型的SQL注入攻击载荷  </span></span><br><span class="line">  </span><br><span class="line"><span class="comment">// 执行查询，这里将触发SQL注入  </span></span><br><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> mapper.selectUserByUsername(userInput);  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 如果查询成功，将输出用户信息（实际上可能会返回所有用户）  </span></span><br><span class="line">System.out.println(user);  </span><br></pre></td></tr></table></figure>

<p><strong>漏洞危害</strong></p>
<ul>
<li>数据泄露：攻击者构造恶意查询语句来获取用户密码、个人信息等敏感数据；</li>
<li>数据篡改：攻击者修改查询条件或执行恶意更新语句，篡改数据库中的数据，破坏数据完整性；</li>
<li>完全控制：攻击者执行多个 SQL 语句，利用漏洞获取操作系统的命令执行权限，从而完全控制受攻击的服务器。</li>
</ul>
<p><strong>漏洞解决方案</strong></p>
<ol>
<li>使用预编译处理条件字段，采用问号的方式读取字段</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;SELECT * FROM test_sql_inject WHERE name = ? and password = ?&quot;</span>;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>在无法使用预编译的地方，使用查询内容过滤，例如 order by，定义一个允许排序的字段白名单，检查输入的数据是否在白名单内，若不在则抛出异常报错</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义允许排序的字段白名单  </span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> List&lt;String&gt; ALLOWED_ORDER_BY_FIELDS = Arrays.asList(<span class="string">&quot;id&quot;</span>, <span class="string">&quot;name&quot;</span>, <span class="string">&quot;date&quot;</span>);  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 方法：获取排序子句  </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getOrderByClause</span><span class="params">(String userInput)</span> &#123;  </span><br><span class="line">	<span class="comment">// 检查用户输入是否在白名单中  </span></span><br><span class="line">	<span class="keyword">if</span> (ALLOWED_ORDER_BY_FIELDS.contains(userInput)) &#123;  </span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;ORDER BY &quot;</span> + userInput;  </span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">		<span class="comment">// 如果不在白名单中，抛出异常  </span></span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Invalid ORDER BY field: &quot;</span> + userInput);  </span><br><span class="line">	&#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>使用 #{} 代替，使用<code>#&#123;&#125;</code>​时，MyBatis会对参数值进行转义，并作为预编译语句的参数传递，从而防止SQL注入。</li>
</ol>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectUserByUsername&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.example.User&quot;</span>&gt;</span>  </span><br><span class="line">    SELECT * FROM users WHERE username = #&#123;username&#125;  </span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>在无法使用预编译的地方，使用查询内容过滤，例如 orderby，在select语句中拼接<if>进行判断，判断该排序字段是否在允许排序的列中，不存在则报错</li>
</ol>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectAllWithOrdering&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.example.MyEntity&quot;</span>&gt;</span>  </span><br><span class="line">    SELECT * FROM test_table order by</span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;column!= null and column != &#x27;&#x27;&quot;</span>&gt;</span>  </span><br><span class="line">        ORDER BY  </span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;column == &#x27;id&#x27; || column == &#x27;name&#x27; || column == &#x27;password&#x27;&quot;</span>&gt;</span>  </span><br><span class="line">            $&#123;column&#125;  </span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span> </span><br></pre></td></tr></table></figure>

<ol start="3">
<li>安全审计和漏洞扫描：定期对服务器和应用程序进行安全审计和漏洞扫描，及时发现并修复存在的安全隐患。</li>
</ol>
<p>‍</p>
<h3 id="XSS-漏洞"><a href="#XSS-漏洞" class="headerlink" title="XSS 漏洞"></a>XSS 漏洞</h3><p><strong>漏洞原理</strong></p>
<p>XSS 漏洞的原理是攻击者将恶意脚本或代码（例如JavaScript）注入到 Web 页面中，当其他用户浏览这个被篡改的页面时，这段脚本在受害者的浏览器中执行，从而导致安全事件。</p>
<p><strong>漏洞产生的场景</strong></p>
<ul>
<li><p>XSS 漏洞有三种类型，分为反射性XSS漏洞、存储型XSS漏洞和DOM漏洞</p>
<ul>
<li>反射性 XSS 漏洞时最常见的 XSS类型，当用户点击这个 URL 时，恶意脚本会被执行，整个过程像是一次反射，攻击者通常通过电子邮件等方式将包含XSS代码的恶意链接发送给用户，诱导其点击。常见测试有：利用JavaScript的<code>alert</code>​函数<code>&lt;script&gt;alert(&#39;XSS&#39;)&lt;/script&gt;</code>​观察浏览器是否弹出警告框，如果弹出警告框，说明存在反射型XSS漏洞，因为恶意代码被成功执行了。</li>
<li>存储型 XSS 漏洞，攻击者利用该漏洞在目标网站上存储恶意脚本到目标服务器，当用户访问这些网站时，恶意代码会被执行。</li>
<li>DOM 型 XSS 漏洞，攻击者通过修改页面结构的 DOM 结构来触发 XSS 漏洞，将恶意代码注入到网页的 DOM 中，然后在用户的浏览器中执行。</li>
</ul>
</li>
</ul>
<p><strong>漏洞危害</strong></p>
<ul>
<li>敏感信息被窃取，如Cookie和会话信息等</li>
<li>网页内容被篡改，向用户展示虚假信息</li>
<li>用户会话被劫持，诱导用户输入个人信息或转账操作等</li>
</ul>
<p><strong>漏洞解决方案</strong></p>
<ol>
<li><p>对输入和输出的内容进行HTML实体编码，涉及前端脚本的内容使用 HtmlUtils.htmpEscape(String) 方法，将其中特殊字符进行转义。</p>
</li>
<li><p>输入验证和过滤：对用户输入进行严格的验证和过滤，过滤输入和输出的特殊字符。</p>
</li>
<li><p>安全审计和漏洞扫描：定期对服务器和应用程序进行安全审计和漏洞扫描，及时发现并修复存在的安全隐患。</p>
</li>
</ol>
<p>‍</p>
<p>‍</p>
<h3 id="任意文件操作漏洞"><a href="#任意文件操作漏洞" class="headerlink" title="任意文件操作漏洞"></a>任意文件操作漏洞</h3><p><strong>漏洞原理</strong></p>
<p>任意文件操作漏洞源于应用程序对用户输入的文件路径或文件名没有进行严格的验证和过滤，攻击者通过构造特定的请求，绕过安全机制，访问或操作服务器上的任意文件。</p>
<p><strong>漏洞产生的场景</strong></p>
<ul>
<li>Web 应用程序进行文件上传功能时，通过使用特定的文件名字，例如&#x2F;..&#x2F;test.txt的方式来下载到不该下载的文件，这是不应该允许的，产生原因是 Linux 系统除了完整的目录，还会有 . 和 .. 表示当前或上级目录，可以通过这些来访问上级目录</li>
</ul>
<p><strong>漏洞危害</strong></p>
<ul>
<li>导致敏感数据泄露，如用户密码、数据库连接配置等</li>
<li>攻击者修改或删除系统文件、系统配置，导致系统无法正确运行，服务中断</li>
</ul>
<p><strong>漏洞解决方案</strong></p>
<ol>
<li>规范化路径，通过使用 Path 类的 normalize() 来规范化路径，这将移除路径中的 . 和 .. 确保路径不再包含多余的上级目录引用。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecureFileAccess</span> &#123;  </span><br><span class="line">    <span class="comment">// 假设这是你的应用程序允许访问的根目录  </span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Path</span> <span class="variable">ROOT_DIRECTORY</span> <span class="operator">=</span> Paths.get(<span class="string">&quot;/safe/directory&quot;</span>);  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;  </span><br><span class="line">        <span class="comment">// 这是一个模拟的攻击者输入的文件路径，包含恶意路径引用  </span></span><br><span class="line">        <span class="type">String</span> <span class="variable">userInputPath</span> <span class="operator">=</span> <span class="string">&quot;../secret/file.txt&quot;</span>;  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">// 将用户输入转换为Path对象  </span></span><br><span class="line">        <span class="type">Path</span> <span class="variable">userPath</span> <span class="operator">=</span> Paths.get(userInputPath);  </span><br><span class="line">        <span class="comment">// 规范化路径  </span></span><br><span class="line">        <span class="type">Path</span> <span class="variable">normalizedPath</span> <span class="operator">=</span> userPath.normalize();  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">// 解析后的路径必须是根目录的子路径，以防止访问根目录以外的文件  </span></span><br><span class="line">        <span class="type">Path</span> <span class="variable">resolvedPath</span> <span class="operator">=</span> ROOT_DIRECTORY.resolve(normalizedPath).normalize();  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">// 检查解析后的路径是否仍然位于根目录内  </span></span><br><span class="line">        <span class="keyword">if</span> (resolvedPath.startsWith(ROOT_DIRECTORY)) &#123;  </span><br><span class="line">            <span class="keyword">try</span> &#123;  </span><br><span class="line">                <span class="comment">// 如果路径安全，则可以进行文件操作，例如读取文件内容  </span></span><br><span class="line">                <span class="keyword">if</span> (Files.exists(resolvedPath)) &#123;</span><br><span class="line">					...</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">                    System.out.println(<span class="string">&quot;File does not exist: &quot;</span> + resolvedPath.toString());  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;  </span><br><span class="line">                e.printStackTrace();  </span><br><span class="line">                <span class="comment">// 处理文件操作中的异常  </span></span><br><span class="line">            &#125;  </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">            <span class="comment">// 如果路径不安全，则拒绝访问  </span></span><br><span class="line">            System.out.println(<span class="string">&quot;Access denied: attempted to access outside the root directory.&quot;</span>);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>文件路径映射，通过文件映射文件编号与文件路径，初始化并映射好文件路径后，我们读取或下载文件时，通过文件编号去获取到文件真正的路径，然后再通过真路径去下载文件。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecureFileAccessDemo</span> &#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 模拟的文件系统路径映射  </span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;String, Path&gt; FILE_SYSTEM_MAP = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 初始化文件系统映射  </span></span><br><span class="line">    <span class="keyword">static</span> &#123;  </span><br><span class="line">        FILE_SYSTEM_MAP.put(<span class="string">&quot;documents&quot;</span>, Paths.get(<span class="string">&quot;/safe/directory/documents&quot;</span>));  </span><br><span class="line">        FILE_SYSTEM_MAP.put(<span class="string">&quot;images&quot;</span>, Paths.get(<span class="string">&quot;/safe/directory/images&quot;</span>));</span><br><span class="line">        <span class="comment">// 可以根据需要添加更多映射</span></span><br><span class="line">        ...</span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;  </span><br><span class="line">        <span class="comment">// 模拟用户输入的文件路径（可能包含尝试访问未映射路径的恶意输入）  </span></span><br><span class="line">        <span class="type">String</span> <span class="variable">userInput</span> <span class="operator">=</span> <span class="string">&quot;documents/file.txt&quot;</span>;  </span><br><span class="line">        <span class="comment">// 或者是一个恶意输入，例如：&quot;../secret/file.txt&quot;（这个示例中不会被允许）  </span></span><br><span class="line">        <span class="comment">// String userInput = &quot;../secret/file.txt&quot;;  </span></span><br><span class="line">  </span><br><span class="line">        <span class="comment">// 验证并获取实际路径  </span></span><br><span class="line">        <span class="type">Path</span> <span class="variable">actualPath</span> <span class="operator">=</span> getActualPath(userInput);  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">if</span> (actualPath != <span class="literal">null</span>) &#123;  </span><br><span class="line">            <span class="comment">// 路径有效，文件操作（这里只是打印路径作为示例）  </span></span><br><span class="line">            System.out.println(<span class="string">&quot;Access granted: &quot;</span> + actualPath.toString());  </span><br><span class="line">            <span class="comment">// 在这里可以进行文件读取、写入等操作  </span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">            <span class="comment">// 路径无效，拒绝访问  </span></span><br><span class="line">            System.out.println(<span class="string">&quot;Access denied: attempted to access an invalid path.&quot;</span>);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 根据用户输入获取实际路径的方法  </span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Path <span class="title function_">getActualPath</span><span class="params">(String userInput)</span> &#123;  </span><br><span class="line">        <span class="comment">// 分割用户输入以获取映射键（例如，&quot;documents/file.txt&quot; -&gt; &quot;documents&quot;）  </span></span><br><span class="line">        String[] parts = userInput.split(<span class="string">&quot;/&quot;</span>, <span class="number">2</span>);  </span><br><span class="line">        <span class="keyword">if</span> (parts.length &lt; <span class="number">2</span>) &#123;  </span><br><span class="line">            <span class="comment">// 没有提供文件名，只提供了映射键（这种情况可以根据需求处理）  </span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        <span class="type">String</span> <span class="variable">mapKey</span> <span class="operator">=</span> parts[<span class="number">0</span>];  </span><br><span class="line">        <span class="type">String</span> <span class="variable">fileName</span> <span class="operator">=</span> parts[<span class="number">1</span>];  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">// 检查映射键是否有效  </span></span><br><span class="line">        <span class="keyword">if</span> (!FILE_SYSTEM_MAP.containsKey(mapKey)) &#123;  </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">// 构造实际路径（映射值 + 文件名）  </span></span><br><span class="line">        <span class="type">Path</span> <span class="variable">basePath</span> <span class="operator">=</span> FILE_SYSTEM_MAP.get(mapKey);  </span><br><span class="line">        <span class="type">Path</span> <span class="variable">actualPath</span> <span class="operator">=</span> basePath.resolve(fileName).normalize();  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">// 可选：进一步检查实际路径是否仍在允许的根目录内（在这个简单示例中可能不是必需的）  </span></span><br><span class="line">        <span class="comment">// 但对于更复杂的系统，这是一个好习惯，可以防止路径遍历攻击  </span></span><br><span class="line">        <span class="comment">// ...（这里可以添加额外的检查逻辑）  </span></span><br><span class="line">  </span><br><span class="line">        <span class="keyword">return</span> actualPath;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>安全审计和漏洞扫描：定期对服务器和应用程序进行安全审计和漏洞扫描，及时发现并修复存在的安全隐患。</li>
</ol>
<p>‍</p>
<h3 id="文件上传漏洞"><a href="#文件上传漏洞" class="headerlink" title="文件上传漏洞"></a>文件上传漏洞</h3><p><strong>漏洞原理</strong></p>
<p>文件上传漏洞是指Web应用程序在处理用户上传文件的功能时存在安全缺陷，使得攻击者能够上传恶意文件到服务器。通常，Web应用会允许用户上传合法的文件，如图片、文档等，但如果应用程序没有对上传的文件进行充分的验证和过滤，攻击者就有可能上传可执行文件、脚本文件、木马和病毒等。</p>
<p><strong>漏洞产生的场景</strong></p>
<ul>
<li>攻击者通过对文件名进行处理，通过伪装文件后缀来绕过检查，从而上传不符合规范的文件。例如将 .zip文件修改成.png类型，从而绕过检查，上传至服务器。</li>
</ul>
<p><strong>漏洞危害</strong></p>
<ul>
<li>代码执行：如果上传的是恶意脚本或木马被执行，导致系统无法正常允许或服务中断</li>
<li>上传的恶意文件可能被用于进行各种攻击，如命令注入攻击等，这些攻击可以导致服务器崩溃、数据泄露或被攻击者完全控制。</li>
</ul>
<p><strong>漏洞解决方案</strong></p>
<ol>
<li><p>通过判断文件头的方式判断文件类型，例如文件名包含什么字符，就映射什么类型的文件，如果不正确就返回报错</p>
</li>
<li><p>严格过滤和验证，对上传的文件进行严格的验证和过滤，确保文件类型、内容符合安全要求</p>
</li>
<li><p>限制上传文件大小，防止攻击者上传非常大的文件耗尽服务器资源或造成拒绝服务器攻击</p>
</li>
<li><p>将上传的文件存储在安全目录，确保该目录的访问权限受到严格控制</p>
</li>
<li><p>安全审计和漏洞扫描：定期对服务器和应用程序进行安全审计和漏洞扫描，及时发现并修复存在的安全隐患。</p>
</li>
</ol>
<p>‍</p>
<h3 id="SSRF-漏洞"><a href="#SSRF-漏洞" class="headerlink" title="SSRF 漏洞"></a>SSRF 漏洞</h3><p><strong>漏洞原理</strong></p>
<p>SSRF 的原理在于 Web 应用程序在处理用户输入时，未能有效地过滤和限制目标地址，导致攻击者可以构造恶意的请求，由服务器发起对内部系统的访问。由于请求是由服务器发起的，因此服务器能够请求到与自身连接但与外网隔离的内部系统，从而泄露内部系统的敏感信息或进行攻击。</p>
<p><strong>漏洞产生的场景</strong></p>
<ul>
<li>应用程序接受用户输入的URL，并通过该URL读取外部请求的响应，最后将外部请求的响应返回给客户端。</li>
</ul>
<p><strong>漏洞危害</strong></p>
<ul>
<li>攻击者利用 SSRF 漏洞读取服务器本地文件，敏感信息泄露</li>
<li>攻击者通过构造大量恶意请求，消耗服务器资源，导致拒绝服务攻击</li>
<li>攻击者利用 SSRF 漏洞对内网进行端口扫描，获取内网主机的端口和服务信息</li>
</ul>
<p><strong>漏洞解决方案</strong></p>
<ol>
<li><p>白名单机制：限制请求的来源，仅允许可信的IP地址或域名发起请求</p>
</li>
<li><p>用户验证：对用户输入进行严格的验证和过滤，确保输入内容不包含恶意地址或特殊字符</p>
</li>
<li><p>安全审计和漏洞扫描：定期对服务器和应用程序进行安全审计和漏洞扫描，及时发现并修复存在的安全隐患。</p>
</li>
</ol>
<p>‍</p>
<h3 id="命令执行漏洞"><a href="#命令执行漏洞" class="headerlink" title="命令执行漏洞"></a>命令执行漏洞</h3><p><strong>漏洞原理</strong></p>
<p>又称远程代码执行漏洞，主要来源于程序未正确验证或过滤用户输入，当应用程序需要调用执行系统命令的函数时，如果未对用户输入进行严格的过滤和验证，攻击者通过构造恶意命令参数来执行任意系统命令，这些命令被应用程序直接传递给底层操作系统，从而导致未授权的操作或系统权限的获取。</p>
<p><strong>漏洞产生的场景</strong></p>
<ul>
<li>当使用ProcessBuilder 或 Runtime.getRuntime().exec() 执行方法时，由用户输入命令，原本是实现一个 ping 服务器的命令观察网络连通性，但经过攻击者恶意构造拼接成 ping &amp; ipconfig 时，导致我们执行的结果不仅仅是获取ping的回复还会获取本机的ip地址。</li>
</ul>
<p><strong>漏洞危害</strong></p>
<ul>
<li>敏感信息泄露</li>
<li>攻击者通过执行恶意代码来破坏系统正常运行，导致服务中断</li>
<li>通过恶意命令执行漏洞提升权限，从而完全控制系统，系统受影响</li>
</ul>
<p><strong>漏洞解决方案</strong></p>
<ol>
<li>避免直接将用户输入的命令直接传递给系统命令执行器</li>
<li>对接收的用户输入，进行严格的验证和过滤，过滤掉潜在的恶意代码。</li>
<li>安全审计和漏洞扫描：定期对服务器和应用程序进行安全审计和漏洞扫描，及时发现并修复存在的安全隐患。</li>
</ol>
<p>‍</p>
<h3 id="XXE-漏洞"><a href="#XXE-漏洞" class="headerlink" title="XXE 漏洞"></a>XXE 漏洞</h3><p><strong>漏洞原理</strong></p>
<p>xml 外部实体注入漏洞，问题主要出自外部资源的申请以及外部实体引用这部分特性中。</p>
<p><strong>漏洞产生的场景</strong></p>
<p>发生在应用程序解析 XML 的方法中，攻击者通过模拟外部实体来获取到服务器内的文件内容。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span>  </span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">foo</span> [   </span></span><br><span class="line"><span class="meta">    <span class="meta">&lt;!ENTITY <span class="keyword">xxe</span> <span class="keyword">SYSTEM</span> <span class="string">&quot;file:///etc/passwd&quot;</span>&gt;</span>  </span></span><br><span class="line"><span class="meta">]&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">root</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">element</span>&gt;</span><span class="symbol">&amp;xxe;</span><span class="tag">&lt;/<span class="name">element</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>漏洞危害</strong></p>
<ul>
<li>私密文件读取</li>
<li>恶意命令执行</li>
<li>内网端口扫描，信息泄露</li>
<li>攻击内网网站，服务器崩溃</li>
</ul>
<p><strong>漏洞解决方案</strong></p>
<ol>
<li>禁止外部实体的引用，使用saxBuilder.setFeature方法对外部实体的引用进行禁用</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">XXEPreventionExample</span> &#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;  </span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">            <span class="comment">// 创建SAXBuilder实例  </span></span><br><span class="line">            <span class="type">SAXBuilder</span> <span class="variable">saxBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SAXBuilder</span>();  </span><br><span class="line">  </span><br><span class="line">            <span class="comment">// 禁用DTD处理（可选）  </span></span><br><span class="line">            saxBuilder.setFeature(<span class="string">&quot;http://apache.org/xml/features/disallow-doctype-decl&quot;</span>, <span class="literal">true</span>);  </span><br><span class="line">            saxBuilder.setFeature(<span class="string">&quot;http://xml.org/sax/features/external-general-entities&quot;</span>, <span class="literal">false</span>);  </span><br><span class="line">            saxBuilder.setFeature(<span class="string">&quot;http://xml.org/sax/features/external-parameter-entities&quot;</span>, <span class="literal">false</span>);  </span><br><span class="line">  </span><br><span class="line">            <span class="comment">// 解析XML文件（这里使用文件作为示例，你也可以使用字符串或输入流）  </span></span><br><span class="line">            <span class="type">File</span> <span class="variable">xmlFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;path/to/your/xmlfile.xml&quot;</span>);  </span><br><span class="line">            <span class="type">Document</span> <span class="variable">document</span> <span class="operator">=</span> saxBuilder.build(xmlFile);  </span><br><span class="line">  </span><br><span class="line">            <span class="comment">// 处理document对象  </span></span><br><span class="line">            System.out.println(<span class="string">&quot;XML文件已成功解析！&quot;</span>); </span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (ParserConfigurationException | IOException | SAXException e) &#123;  </span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>对接收到的XML数据进行严格的验证和过滤，确保不包含恶意外部实体引用。</li>
<li>安全审计和漏洞扫描：定期对服务器和应用程序进行安全审计和漏洞扫描，及时发现并修复存在的安全隐患。</li>
</ol>
<p>‍</p>
<h3 id="越权漏洞"><a href="#越权漏洞" class="headerlink" title="越权漏洞"></a>越权漏洞</h3><p><strong>漏洞原理</strong></p>
<p>攻击者通过访问未经授权的资源或执行未经授权的操作来破坏系统的安全性。Java应用中，越权漏洞通常出现在权限验证不足或缺乏权限验证的情况下。</p>
<p><strong>漏洞产生的场景</strong></p>
<p>水平越权：发生在具有相同权限级别的用户之间，攻击者利用这些漏洞，访问其它用户拥有的资源或执行不应是他执行的操作。</p>
<p>垂直越权：发生在具有多个权限级别的系统中，攻击者利用这些漏洞，从一个低权限跳转到一个更高的权限。</p>
<p><strong>漏洞危害</strong></p>
<ul>
<li>系统安全性被破坏</li>
<li>未被授权的资源被非法访问或修改</li>
</ul>
<p><strong>漏洞解决方案</strong></p>
<ol>
<li>实施严格的访问控制：对用户进行身份验证，仅允许其执行允许的操作</li>
<li>验证用户输入：对所有用户的输入进行严格的验证和过滤，仔细验证用户请求的合法性</li>
<li>最小权限原则：分配用户权限时，只给予用户所需的最低权限级别</li>
<li>安全审计和漏洞扫描：定期对服务器和应用程序进行安全审计和漏洞扫描，及时发现并修复存在的安全隐患。</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/11/07/%E5%B8%B8%E8%A7%81%E6%BC%8F%E6%B4%9E%E6%BC%94%E7%A4%BA%E4%B8%8E%E4%BF%AE%E5%A4%8D%E5%BB%BA%E8%AE%AE/" data-id="cm3y4jduc0003csegferz89uq" data-title="常见漏洞演示与修复建议" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-如何基于Redis实现分布式锁" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/10/18/%E5%A6%82%E4%BD%95%E5%9F%BA%E4%BA%8ERedis%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/" class="article-date">
  <time class="dt-published" datetime="2024-10-18T09:34:47.000Z" itemprop="datePublished">2024-10-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/10/18/%E5%A6%82%E4%BD%95%E5%9F%BA%E4%BA%8ERedis%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/">如何基于Redis实现分布式锁?</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h4 id="什么是分布式锁？"><a href="#什么是分布式锁？" class="headerlink" title="什么是分布式锁？"></a>什么是分布式锁？</h4><ul>
<li>Java中，对于单机多线程，我们通常使用 ReentrantLock 类和 synchronized 关键字这类 JDK 自带的本地锁来控制多个线程对本地资源的访问。</li>
<li>线程访问共享资源是互斥的，同一时刻只有一个线程能够获取到本地锁来访问共享资源。</li>
<li>分布式系统，不同的服务&#x2F;客户端运行在独立的JVM进程中，无法通过使用本地锁来实现资源的互斥访问，于是分布式锁诞生了。</li>
<li>举例：秒杀系统，为了防止商品超卖。需要对库存进行加锁以实现对数据库的库存的同步访问操作。订单 Server 可能运行在不同的服务器中，所以我们需要使用到分布式锁，来帮助我们实现分布式系统下的共享资源的互斥访问。</li>
</ul>
<h4 id="分布式锁需要满足的条件"><a href="#分布式锁需要满足的条件" class="headerlink" title="分布式锁需要满足的条件"></a>分布式锁需要满足的条件</h4><ul>
<li>互斥：任意时刻，锁只能被一个线程持有；</li>
<li>高可用：锁服务是高可用的，即使释放锁的逻辑出现了问题，锁最终还是要被释放，不能影响其它线程对共享资源的访问。</li>
<li>可重入：一个节点获取锁之后，还可以再获取锁。<br>通常情况下，我们基于 Redis 或 ZooKeeper 实现分布式锁。</li>
</ul>
<h4 id="如何基于-Redis-实现简易分布式锁？"><a href="#如何基于-Redis-实现简易分布式锁？" class="headerlink" title="如何基于 Redis 实现简易分布式锁？"></a>如何基于 Redis 实现简易分布式锁？</h4><ul>
<li>SETNX 命令可以帮助我们实现互斥，SETNX：SET IF NOT EXISTS，若 key 不存在，设置 key 的值；key 存在，则不操作。<blockquote>
<p> SETNX lockKey uniqueValue<br>(integer) 1<br> SETNX lockKey uniqueValue<br>(integer) 0</p>
</blockquote>
</li>
<li>释放锁：直接通过 DEL 命令删除对应 key。<blockquote>
<p> DEL lockKey<br>(integer) 1</p>
</blockquote>
</li>
<li>为了防止误删除到其它锁，建议使用 LUA 脚本通过 key 对应的 value（唯一值）来判断。</li>
<li>选用 LUA 脚本是为了保证释放锁操作的原子性<blockquote>
<p> &#x2F;&#x2F; 释放锁时，先比较锁对应的 value 值是否相等，防止锁误释放<br>if redis.call(“get”,KEYS[1]) &#x3D;&#x3D; ARGV[1] then<br>    return redis.call(“del”,KEYS[1])<br>else<br>    return 0<br>end</p>
</blockquote>
</li>
</ul>
<p>以上是一个较简单的 Redis 分布式锁实现，但程序如果遇到一些问题导致锁资源无法释放的时候，我们需要采取另一种方案，给锁设置过期时间。</p>
<h4 id="为什么要给锁设置一个过期时间？"><a href="#为什么要给锁设置一个过期时间？" class="headerlink" title="为什么要给锁设置一个过期时间？"></a>为什么要给锁设置一个过期时间？</h4><p>为了避免锁无法释放，我们需要强制给 key （锁）设置一个过期时间。</p>
<blockquote>
<p>127.0.0.1:6379&gt; SET lockKey uniqueValue EX 3 NX<br>OK</p>
</blockquote>
<ul>
<li>lockKey ：加锁的锁名；</li>
<li>uniqueValue ：能够唯一标示锁的随机字符串；</li>
<li>NX ：只有当 -lockKey 对应的 key 值不存在的时候才能 SET 成功；</li>
<li>EX ：过期时间设置（秒为单位）EX 3 标示这个锁有一个 3 秒的自动过期时间。与 EX 对应的是 PX（毫秒为单位），这两个都是过期时间设置。</li>
</ul>
<p>需要保证的是：指定 key 的值和指定过期时间是一个原子操作。</p>
<p>锁无法释放的问题解决之后，引出了一个新问题：当程序获取了锁资源，且在操作共享资源的时间大于了锁过期时间，进而导致分布式锁失效，但如果锁过期时间设置过长，又会影响性能，此时引入了锁自动续期的概念。</p>
<h4 id="如何实现锁的优雅续期？"><a href="#如何实现锁的优雅续期？" class="headerlink" title="如何实现锁的优雅续期？"></a>如何实现锁的优雅续期？</h4><ul>
<li>Java 开发的解决方案是：Redisson，其它语言的解决方案可以参考官网。</li>
<li>Redisson 中的分布式锁自带锁自动续期机制，使用非常简单，原理：提供了一个专门监控和续期锁的 WATCH DOG（看门狗机制）若锁到了过期时间，但操作共享资源的线程还未执行完毕的话，WATCH DOG 会不断延长锁的过期时间，进而保证锁不会因为超时而被释放。</li>
</ul>
<p>看门狗的名字的由来源于方法：getLockWatchdogTimeout()，这个方法返回的是看门狗给锁续期的过期时间，默认为 30 秒。<br>具体逻辑：默认情况下每过 10 秒，看门狗会判断是否需要执行续期操作，若需要续期会将锁的超时时间设置为 30 秒，不需要就不进行操作。底层是调用 LUA 脚本实现的续期，这样可以保证续期操作的原子性。</p>
<p>如果手动给锁设置超时时间，将不会使用到 Watch Dog 自动续期机制。</p>
<h4 id="如何实现可重入锁？"><a href="#如何实现可重入锁？" class="headerlink" title="如何实现可重入锁？"></a>如何实现可重入锁？</h4><ul>
<li>可重入锁：一个线程可以多次获取同一把锁，比如一个线程在执行一个带锁的方法，该方法中又调用了另一个需要相同锁的方法，则该线程可以直接执行调用的方法，而无需重新获取锁。</li>
<li>synchronized 和 ReentrantLock 都属于可重入锁。</li>
<li>实现逻辑：线程在获取锁的时候判断是否已获取，如果是则不用重新获取了。通过为每个锁关联一个可重入计数器和一个占有它的线程实现。<ul>
<li>当可重入计数器大于 0 时，则代表锁被占用；再判断占有该锁的线程是否和请求该锁的线程为同一个。</li>
</ul>
</li>
<li>实际项目中不需要手动实现，推荐使用 Redisson，其内置了多种类型的锁，比如可重入锁（Reentrant Lock）、自旋锁（Spin Lock）、公平锁（Fair Lock）、多重锁（MultiLock）、 红锁（RedLock）、 读写锁（ReadWriteLock）</li>
</ul>
<h4 id="Redis-如何解决集群情况下分布式锁的可靠性？"><a href="#Redis-如何解决集群情况下分布式锁的可靠性？" class="headerlink" title="Redis 如何解决集群情况下分布式锁的可靠性？"></a>Redis 如何解决集群情况下分布式锁的可靠性？</h4><p>避免单点故障，Redis 在生产环境下通常以集群化方式部署。</p>
<ul>
<li>由于 Redis 集群数据同步到各个节点时是异步的，如果在 Redis 主节点获取到锁后，在没有同步到其它从节点时，主节点宕机了，此时新的主节点依旧可以获取到锁，说明多个应用服务可以同时获取到同一把锁。针对这个问题，Redis 设计了 RedLock 算法来解决，也就是红锁。<ul>
<li>RedLock 算法思想：让客户端向 Redis 集群中的多个独立的 Redis 实例依次请求申请加锁，如果客户端能够和半数以上的实例成功地完成加锁操作，那么我们就认为，客户端成功地获得分布式锁，否则加锁失败。</li>
<li>即使部分 Redis 节点出现问题，只要保证 Redis 集群中有半数以上的 Redis 节点可用，分布式锁服务就是正常的。Redlock 是直接操作 Redis 节点的，并不是通过 Redis 集群操作的，这样才可以避免 Redis 集群主从切换导致的锁丢失问题。</li>
</ul>
</li>
</ul>
<p>实际项目中不建议使用 Redlock 算法，成本和收益不成正比。如果不是非要实现绝对可靠的分布式锁的话，其实单机版 Redis 就完全够了，实现简单，性能也非常高。<br>如果必须要实现一个绝对可靠的分布式锁的话，可以基于 ZooKeeper 来做，只是性能会差一些。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/10/18/%E5%A6%82%E4%BD%95%E5%9F%BA%E4%BA%8ERedis%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/" data-id="cm3y4jdu80001csegctzz5a3u" data-title="如何基于Redis实现分布式锁?" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-pdd面经" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/10/12/pdd%E9%9D%A2%E7%BB%8F/" class="article-date">
  <time class="dt-published" datetime="2024-10-12T08:54:10.000Z" itemprop="datePublished">2024-10-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/10/12/pdd%E9%9D%A2%E7%BB%8F/">pdd面经</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="pdd面经"><a href="#pdd面经" class="headerlink" title="pdd面经"></a>pdd面经</h2><h3 id="对象会在什么时候进入老年代？"><a href="#对象会在什么时候进入老年代？" class="headerlink" title="对象会在什么时候进入老年代？"></a>对象会在什么时候进入老年代？</h3><p>一般来说，对象会在年轻代里分配，然后随着时间的推移和垃圾回收的处理，满足某种设定条件后，对象会从新生代进入到老年代中。</p>
<ol>
<li>长期存活的对象<ol>
<li>年轻对象在经历多轮的垃圾回收后，即存活足够长的时间后，会晋升到老年代</li>
<li>每次 GC 未被回收的对象，其年龄会增加。当对象的年龄超过一定阈值（JVM参数 -XX:MaxTenuringThreshold，默认15，可进行调整），它就会被移动到老年代</li>
</ol>
</li>
<li>大对象直接进入<ol>
<li>为了避免在年轻代中频繁复制大对象，JVM 提供一种策略：允许大对象直接在老年代中进行分配</li>
<li>所谓的大对象，指的是其所占用内存空间大小超过了设定的阈值（JVM参数 -XX:PretenureSizeThreshold），直接在老年代分配可以减少数据复制</li>
</ol>
</li>
<li>动态对象年龄判定<ol>
<li>除了固定的年龄阈值，JVM 还会根据各个年龄段对象的存活大小和内存空间等因素动态调整对象的晋升策略</li>
<li>例如：在 Survivor 空间中相同年龄的所有对象大小总和大于 Survivor 空间的一半，那么年龄大于或等于该年龄的对象可以直接进入老年代</li>
</ol>
</li>
</ol>
<h3 id="Error-和-Exception-异同？"><a href="#Error-和-Exception-异同？" class="headerlink" title="Error 和 Exception 异同？"></a>Error 和 Exception 异同？</h3><p>Throwable 是所有错误和异常的父类，它有两个主要的子类，Error 和 Exception</p>
<ul>
<li>Error 类代表一类严重的错误，这类错误程序无法处理，如 OutOfMemoryError 内存溢出、StackOverflowError 栈溢出等，这类错误与JVM运行状态有关</li>
<li>Exception 类代表程序可处理的异常，分为两大类：编译时异常（Checked Exception）和运行时异常（Runtime Exception）</li>
</ul>
<p>try-catch-finally 抛出异常，catch 和 finally 的异常可以同时抛出吗？</p>
<ul>
<li>在代码中允许 catch 块和 finally 块同时抛出异常，但由于 finally 块中的异常会覆盖并且向上传递，导致 catch 块的异常被丢弃，最终抛出的将是 finally 块的异常</li>
</ul>
<h3 id="Java-多线程中，同步与互斥是什么？"><a href="#Java-多线程中，同步与互斥是什么？" class="headerlink" title="Java 多线程中，同步与互斥是什么？"></a>Java 多线程中，同步与互斥是什么？</h3><p>互斥，代表不同线程通过竞争进入临界区（共享数据或硬件资源），为了防止冲突，在有限的时间内只允许其中一个线程独占共享资源，不允许同时操作。</p>
<p>同步，多个线程彼此合作，通过一定逻辑共同完成一个任务。一般同步关系中往往包含了互斥关系，同时临界区的资源会按照某种逻辑顺序进行访问，如先生产后使用等。</p>
<p>Java 中，我们要保护一个资源在同一时间内只被一个线程占用，通常使用 synchronized 关键字或 Lock 接口中的实现类（如 ReentrantLock）来给资源加锁</p>
<p>锁在操作系统层面的意思就是互斥，代表某个线程占用锁（进入临界区）后，其它线程不能再进入临界区，达到互斥的目的</p>
<p>锁需要处理的问题：</p>
<ul>
<li>拿到锁的对象</li>
<li>抢占锁的规则，可重入锁、读写锁</li>
<li>抢占不到锁的规则，等待、自旋、阻塞、超时</li>
<li>锁被释放后的规则，通知所有线程一起抢、只告诉优先级最高的抢</li>
</ul>
<p>恰当的使用锁机制，就能解决同步或互斥的问题。</p>
<h3 id="synchronized-和-ReentrantLock-的区别"><a href="#synchronized-和-ReentrantLock-的区别" class="headerlink" title="synchronized 和 ReentrantLock 的区别"></a>synchronized 和 ReentrantLock 的区别</h3><p>synchronized 是一个关键字，而 ReentrantLock 是 Lock 接口的一个实现</p>
<ul>
<li>ReentrantLock 依赖 AQS，支持响应中断、超时、尝试获取锁</li>
<li>synchronized 在执行完同步代码块后，JVM 会自动释放锁，而 ReentrantLock 必须手动调用 unlock() 进行释放（通常在 finally 块中）</li>
<li>synchronized 支持非公平锁，ReentrantLock 支持公平锁 &amp; 非公平锁</li>
</ul>
<h3 id="产生死锁的条件"><a href="#产生死锁的条件" class="headerlink" title="产生死锁的条件"></a>产生死锁的条件</h3><ul>
<li>互斥条件：资源不能被多个进程共享，即资源一次只能被一个线程占用；如果一个资源已分配给了一个线程，其它线程必须等待，直到该资源被释放</li>
<li>持有并等待条件：一个进程已经持有了至少一个资源，同时还在等待获取其它被占用的资源。在此期间，该进程不会释放已持有的资源</li>
<li>不可剥夺条件：已分配给进程的资源不能被强制剥夺，只有持有该资源的进程才能主动释放资源</li>
<li>循环等待条件：存在一个进程集合 p1、p2、p3… 其中 p1 等待 p2 的释放，p2 等待 p3 的释放，pn 等待 p1 的资源，形成一个进程等待环</li>
</ul>
<h3 id="HTTP-状态码有哪些？"><a href="#HTTP-状态码有哪些？" class="headerlink" title="HTTP 状态码有哪些？"></a>HTTP 状态码有哪些？</h3><p>总共有五大类，分别从 1xx - 5xx</p>
<ul>
<li>1xx 属于提示信息</li>
<li>2xx 成功，表示服务器成功处理了客户端的请求</li>
<li>3xx 重定向，表示客户端请求的资源发生了变动，需要客户端使用新的 URL 重新发送请求以便获取资源(访问新的 URL)</li>
<li>4xx 报文有误，表示客户端发送过来的报文格式或数据不正确，服务器无法处理</li>
<li>5xx 报文正确，但服务器内部出现问题，有可能是服务器宕机或接口失效</li>
</ul>
<p>常见的错误码：</p>
<ul>
<li>200：请求成功</li>
<li>301：永久重定向 302：临时重定向</li>
<li>403：禁止访问 404：无法找到此页面 405：请求的方法类型不支持</li>
<li>500：服务器内部报错</li>
</ul>
<h3 id="TCP-如何保证传输的可靠性？"><a href="#TCP-如何保证传输的可靠性？" class="headerlink" title="TCP 如何保证传输的可靠性？"></a>TCP 如何保证传输的可靠性？</h3><p>TCP 协议通过连接管理、序列号、确认应答、超时重传、流量控制、拥塞控制来保证可靠性。</p>
<ul>
<li>连接管理：三次握手和四次挥手</li>
<li>序列号：TCP 将每个字节的数据都进行了编号，能够防止数据丢失、避免数据重复、保证有序性，按照序列号顺序进行数据包还原</li>
<li>确认应答：接收方收到数据后，会回传 ACK 报文，报文中带有此次确认的序列号，用于告知发送方此次接收数据的情况。指定时间发送端仍未收到确认应答，就会启动超时重传</li>
<li>超时重传：主要两种场景，数据包丢失和确认包丢失。数据包丢失，若发送端未收到确认应答，会启动超时重传，向接收端重新发送数据包。确认包丢失，当接收端收到重复的数据包（通过序列号确定），会将其丢弃，并重新回传 ACK 报文</li>
<li>流量控制：接收端处理数据速度有限，如果发送端发送数据的时间过快，会导致接收端的缓冲区溢出，进而导致丢包。为了避免此情况，TCP 支持根据接收端的处理能力来决定发送端的发送速度，这就是流量控制，底层是通过在 TCP 报文首部维护一个滑动窗口实现。</li>
<li>拥塞控制：当网络堵塞严重时，发送端减少数据发送。底层是通过发送端维护一个拥塞窗口实现，发送端的发送速度，取决于滑动窗口和拥塞窗口中的最小值。</li>
</ul>
<h3 id="拥塞控制的具体逻辑"><a href="#拥塞控制的具体逻辑" class="headerlink" title="拥塞控制的具体逻辑"></a>拥塞控制的具体逻辑</h3><p>TCP 拥塞控制是为了防止网络过载而采取的一系列措施，这些措施能够动态调整数据传输速率以适应网络状态，主要包括以下几种算法和策略：</p>
<ul>
<li>慢启动：当 TCP 连接建立或发生丢包重传时，TCP 从一个相对较小的拥塞窗口开始。这一窗口随着成功收到确认（ACK）而指数增长。</li>
<li>拥塞避免：当拥塞窗口达到某个阈值后，TCP 进入拥塞避免阶段。这个阶段拥塞窗口以线性增长方式增加。</li>
<li>快速重传：发送方在未收到某个数据包的 ACK 、接收方多次确认相同的数据包时，发送方会立即重传缺失的数据包，而不是等待重传定时器超时。</li>
<li>快速恢复：快速重传机制后，TCP 进入快速恢复阶段。TCP 在丢包之后不会完全降低其传输速率，而是建立一个新的目标以便快速返回正常状态。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/10/12/pdd%E9%9D%A2%E7%BB%8F/" data-id="cm3y4jdud0005cseg8dvw47of" data-title="pdd面经" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-hello-world" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/10/12/hello-world/" class="article-date">
  <time class="dt-published" datetime="2024-10-12T08:32:09.000Z" itemprop="datePublished">2024-10-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/10/12/hello-world/">Hello World</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>开始我的博客之旅</p>
<p>种一棵树最好的时间是十年前，其次是现在，只要选择开始，什么时候都不算晚</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/10/12/hello-world/" data-id="cm3y4jdu40000cseg8fn94oye" data-title="Hello World" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/11/">November 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/10/">October 2024</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2024/11/26/%E9%9D%A2%E7%BB%8F%EF%BC%882024.11.18-2024.11.24%EF%BC%89/">面经（2024.11.18-2024.11.24）</a>
          </li>
        
          <li>
            <a href="/2024/11/26/%E9%9D%A2%E7%BB%8F/">面经</a>
          </li>
        
          <li>
            <a href="/2024/11/07/%E5%B8%B8%E8%A7%81%E6%BC%8F%E6%B4%9E%E6%BC%94%E7%A4%BA%E4%B8%8E%E4%BF%AE%E5%A4%8D%E5%BB%BA%E8%AE%AE/">常见漏洞演示与修复建议</a>
          </li>
        
          <li>
            <a href="/2024/10/18/%E5%A6%82%E4%BD%95%E5%9F%BA%E4%BA%8ERedis%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/">如何基于Redis实现分布式锁?</a>
          </li>
        
          <li>
            <a href="/2024/10/12/pdd%E9%9D%A2%E7%BB%8F/">pdd面经</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2024 Hushenghui<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>